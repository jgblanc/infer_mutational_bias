---
title: "STAN_model"
author: "Jennifer Blanc"
date: "4/13/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
set.seed(407)
```

## Intro  

Model:  

$$\vec{\hat{\beta}} = \vec{\beta_T} + \sum_i \lambda_i^{1/2} \vec{V} \beta_i + \vec{e}$$  

$$D_l = 1 \text{   if  } \beta_l > 0$$
$$D_l = 0 \text{   if  } \beta_l < 0$$  

$$R = \sum_lD_l$$  

$$R \sim Bin(1/2, L)$$

$$\hat{\beta} = \beta + \sum_i \lambda_i^{1/2} V \beta_i + e$$

## Functions to Simulate Data  

Function to simulate SNP loadings:  
* n = number of PCs
* L = number of SNPs
* loading_mean = used to skew the loadings 
* loading_sd = standard deviation used to draw loadings  
```{r}
simulate_loadings <- function(L, n, loading_mean, loading_sd) {
  loadings <- matrix(0, ncol = L, nrow = n)
  for (i in 1:n) {
   loadings[i,] <- rnorm(L, mean = loading_mean, sd = loading_sd) # skew mean
  }
  return(loadings)
}
``` 

Function to simulate Beta hats:  
* n = number of PCs
* L = number of SNPs
* Bpc = the true value of $\beta_{PC}$  
* epsilon_sd = standard deviation of the error
* loadings = SNP loadings simulated above

```{r}
calc_beta_hat <- function(L, n, Btrue, Bpc, epsilon_sd, loadings) {
  Bhat <- rep(0, L)
  mat <- matrix(NA, ncol = L, nrow = n)
  for (i in 1:n) {
    mat[i,] <- Bpc[i] * loadings[i,]
  }
  loading_time_pc <- colSums(mat)
  Bhat <- Btrue + loading_time_pc + rnorm(L, mean = 0, sd = epsilon_sd)
  return(Bhat)
}
```


## STAN model 

```{stan, output.var="simple", eval=T}
functions {  
  real my_ll_lpmf(int R, int L, real b){
    real lprob;
    lprob = lchoose(L, R) + log((b)^(R)) + log((1 - b)^(L - R));
    return lprob;
  }
}
data {
  int<lower=0> L;   // number of Beta hats
  int<lower=0> n;   // number of predictors (PCs)
  matrix[L, n] x;   // predictor matrix (loadings n x L)
  vector[L] y;      // outcome vector
  real b; // 
}
parameters {
  vector[n] beta;       // coefficients for predictors
  real<lower=0> sigma;  // error scale
}
model {
  int R;
  vector[L] true_beta;
  real true_causal;
  R = 0;
  true_beta = x*beta;
  //print(R, true_beta);
  for (i in 1:L) {
    true_causal = y[i] - true_beta[i];
    if (true_causal > 0) {
      R = R + 1;
    }
  };
  R ~ my_ll_lpmf(L, b); 
  //print("R:", R, "true_beta:", true_beta);
  //print("R:", R);
  y ~ normal(x * beta, sigma);  // likelihood
}
```

## Fit model 

Function to fit model 
```{r, warning=FALSE}
fit_model <- function(L, n, loading_mean, loading_sd, Bpc, epsilon_sd, Btrue, b) {
  loadings <- simulate_loadings(L = L, n = n, loading_mean = loading_mean, loading_sd = loading_sd)
  Bhat <- calc_beta_hat(L = L, n = n, Btrue = Btrue, Bpc = Bpc, epsilon_sd = epsilon_sd, loadings = loadings)
  data <- list(y = Bhat, L = L, n = n, x = t(loadings), b=b)
  fit <- sampling(simple, data = data, refresh = 0, chains=4)
  return(fit)
}
```

## Examples  

1 PC with no effect 
```{r}
mod <- fit_model(L = 1000, n = 1, loading_mean = 1, loading_sd = 1, Bpc = 0, epsilon_sd = 1, Btrue = rep(0, 1000), b=0.5)
```

```{r}
fit_ss <- extract(mod)
hist(fit_ss$beta, main = "Posterior")
abline(v=0,col="red")
```

1 PC with Bpc = 2 
```{r, results="hide"}
mod <- fit_model(L = 1000, n = 1, loading_mean = 1, loading_sd = 1, Bpc = 2, epsilon_sd = 1, Btrue = rep(0, 1000), b=0.5)
```

```{r}
fit_ss <- extract(mod)
hist(fit_ss$beta, main = "Posterior")
abline(v=2,col="red")
```

4 PCs no effects 
```{r}
mod <- fit_model(L = 1000, n = 4, loading_mean = 1, loading_sd = 1, Bpc = rep(0,4), epsilon_sd = 1, Btrue = rep(0, 1000), b=0.5)

fit_ss <- extract(mod)
beta <- fit_ss$beta
par(mfrow = c(2,2))
hist(beta[,1])
abline(v=0,col="red")
hist(beta[,2])
abline(v=0,col="red")
hist(beta[,3])
abline(v=0,col="red")
hist(beta[,4])
abline(v=0,col="red")
```

4 PCs - PC 2 has effect = -2 
```{r}
mod <- fit_model(L = 1000, n = 4, loading_mean = 1, loading_sd = 1, Bpc = c(0,-2,0,0), epsilon_sd = 1, Btrue = rep(0, 1000), b=0.5)
 
fit_ss <- extract(mod)
beta <- fit_ss$beta
par(mfrow = c(2,2))
hist(beta[,1])
abline(v=0,col="red")
hist(beta[,2])
abline(v=-2,col="red")
hist(beta[,3])
abline(v=0,col="red")
hist(beta[,4])
abline(v=0,col="red")
```





